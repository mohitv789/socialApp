import { InjectionToken, Injectable, Optional, Inject } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.
 *
 * @param def The route definition type
 */
export function isHttpInterceptorRouteConfig(def) {
    return typeof def !== 'string';
}
/**
 * Injection token for accessing configuration.
 *
 * @usageNotes
 *
 * Use the `Inject` decorator to access the configuration from a service or component:
 *
 * ```
 * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}
 * ```
 */
export const AuthConfigService = new InjectionToken('auth0-angular.config');
/**
 * Gets and sets configuration for the internal Auth0 client. This can be
 * used to provide configuration outside of using AuthModule.forRoot, i.e. from
 * a factory provided by APP_INITIALIZER.
 *
 * @usage
 *
 * ```js
 * // app.module.ts
 * // ---------------------------
 * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';
 *
 * // Provide an initializer function that returns a Promise
 * function configInitializer(
 *   http: HttpClient,
 *   config: AuthClientConfig
 * ) {
 *   return () =>
 *     http
 *       .get('/config')
 *       .toPromise()
 *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here
 * }
 *
 * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot
 * imports: [
 *   // other imports..
 *
 *   HttpClientModule,
 *   AuthModule.forRoot(),   //<- don't pass any config here
 * ],
 * providers: [
 *   {
 *     provide: APP_INITIALIZER,
 *     useFactory: configInitializer,    // <- pass your initializer function here
 *     deps: [HttpClient, AuthClientConfig],
 *     multi: true,
 *   },
 * ],
 * ```
 *
 */
export class AuthClientConfig {
    constructor(config) {
        if (config) {
            this.set(config);
        }
    }
    /**
     * Sets configuration to be read by other consumers of the service (see usage notes)
     *
     * @param config The configuration to set
     */
    set(config) {
        this.config = config;
    }
    /**
     * Gets the config that has been set by other consumers of the service
     */
    get() {
        return this.config;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AuthClientConfig, deps: [{ token: AuthConfigService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AuthClientConfig, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: AuthClientConfig, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [AuthConfigService]
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5jb25maWcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9hdXRoMC1hbmd1bGFyL3NyYy9saWIvYXV0aC5jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBT0EsT0FBTyxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFzQjdFOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsNEJBQTRCLENBQzFDLEdBQXVCO0lBRXZCLE9BQU8sT0FBTyxHQUFHLEtBQUssUUFBUSxDQUFDO0FBQ2pDLENBQUM7QUFvSEQ7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLElBQUksY0FBYyxDQUNqRCxzQkFBc0IsQ0FDdkIsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlDRztBQUVILE1BQU0sT0FBTyxnQkFBZ0I7SUFHM0IsWUFBbUQsTUFBbUI7UUFDcEUsSUFBSSxNQUFNLEVBQUUsQ0FBQztZQUNYLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkIsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLE1BQWtCO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7T0FFRztJQUNILEdBQUc7UUFDRCxPQUFPLElBQUksQ0FBQyxNQUFvQixDQUFDO0lBQ25DLENBQUM7K0dBdkJVLGdCQUFnQixrQkFHSyxpQkFBaUI7bUhBSHRDLGdCQUFnQixjQURILE1BQU07OzRGQUNuQixnQkFBZ0I7a0JBRDVCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzswQkFJbkIsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBdXRoMENsaWVudE9wdGlvbnMsXG4gIENhY2hlTG9jYXRpb24sXG4gIEdldFRva2VuU2lsZW50bHlPcHRpb25zLFxuICBJQ2FjaGUsXG59IGZyb20gJ0BhdXRoMC9hdXRoMC1zcGEtanMnO1xuXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIERlZmluZXMgYSBjb21tb24gc2V0IG9mIEhUVFAgbWV0aG9kcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gSHR0cE1ldGhvZCB7XG4gIEdldCA9ICdHRVQnLFxuICBQb3N0ID0gJ1BPU1QnLFxuICBQdXQgPSAnUFVUJyxcbiAgUGF0Y2ggPSAnUEFUQ0gnLFxuICBEZWxldGUgPSAnREVMRVRFJyxcbiAgSGVhZCA9ICdIRUFEJyxcbn1cblxuLyoqXG4gKiBEZWZpbmVzIHRoZSB0eXBlIGZvciBhIHJvdXRlIGNvbmZpZyBlbnRyeS4gQ2FuIGVpdGhlciBiZTpcbiAqXG4gKiAtIGFuIG9iamVjdCBvZiB0eXBlIEh0dHBJbnRlcmNlcHRvclJvdXRlQ29uZmlnXG4gKiAtIGEgc3RyaW5nXG4gKi9cbmV4cG9ydCB0eXBlIEFwaVJvdXRlRGVmaW5pdGlvbiA9IEh0dHBJbnRlcmNlcHRvclJvdXRlQ29uZmlnIHwgc3RyaW5nO1xuXG4vKipcbiAqIEEgY3VzdG9tIHR5cGUgZ3VhcmQgdG8gaGVscCBpZGVudGlmeSByb3V0ZSBkZWZpbml0aW9ucyB0aGF0IGFyZSBhY3R1YWxseSBIdHRwSW50ZXJjZXB0b3JSb3V0ZUNvbmZpZyB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gZGVmIFRoZSByb3V0ZSBkZWZpbml0aW9uIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcoXG4gIGRlZjogQXBpUm91dGVEZWZpbml0aW9uXG4pOiBkZWYgaXMgSHR0cEludGVyY2VwdG9yUm91dGVDb25maWcge1xuICByZXR1cm4gdHlwZW9mIGRlZiAhPT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIEh0dHBJbnRlcmNlcHRvclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEh0dHBJbnRlcmNlcHRvckNvbmZpZyB7XG4gIGFsbG93ZWRMaXN0OiBBcGlSb3V0ZURlZmluaXRpb25bXTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBhIHNpbmdsZSBpbnRlcmNlcHRvciByb3V0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEh0dHBJbnRlcmNlcHRvclJvdXRlQ29uZmlnIHtcbiAgLyoqXG4gICAqIFRoZSBVUkwgdG8gdGVzdCwgYnkgc3VwcGx5aW5nIHRoZSBVUkwgdG8gbWF0Y2guXG4gICAqIElmIGB0ZXN0YCBpcyBhIG1hdGNoIGZvciB0aGUgY3VycmVudCByZXF1ZXN0IHBhdGggZnJvbSB0aGUgSFRUUCBjbGllbnQsIHRoZW5cbiAgICogYW4gYWNjZXNzIHRva2VuIGlzIGF0dGFjaGVkIHRvIHRoZSByZXF1ZXN0IGluIHRoZVxuICAgKiAgW1wiQXV0aG9yaXphdGlvblwiIGhlYWRlcl0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtb2F1dGgtdjItYmVhcmVyLTIwI3NlY3Rpb24tMi4xKS5cbiAgICpcbiAgICogSWYgdGhlIHRlc3QgZG9lcyBub3QgcGFzcywgdGhlIHJlcXVlc3QgcHJvY2VlZHMgd2l0aG91dCB0aGUgYWNjZXNzIHRva2VuIGF0dGFjaGVkLlxuICAgKlxuICAgKiBBIHdpbGRjYXJkIGNoYXJhY3RlciBjYW4gYmUgdXNlZCB0byBtYXRjaCBvbmx5IHRoZSBzdGFydCBvZiB0aGUgVVJMLlxuICAgKlxuICAgKiBAdXNhZ2Vub3Rlc1xuICAgKlxuICAgKiAnL2FwaScgLSBleGFjdGx5IG1hdGNoIHRoZSByb3V0ZSAvYXBpXG4gICAqICcvYXBpLyonIC0gbWF0Y2ggYW55IHJvdXRlIHRoYXQgc3RhcnRzIHdpdGggL2FwaS9cbiAgICovXG4gIHVyaT86IHN0cmluZztcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIEh0dHBSZXF1ZXN0LnVybCB2YWx1ZSwgYWxsb3dpbmcgeW91IHRvIGRvXG4gICAqIGFueSBraW5kIG9mIGZsZXhpYmxlIG1hdGNoaW5nLlxuICAgKlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlblxuICAgKiBhbiBhY2Nlc3MgdG9rZW4gaXMgYXR0YWNoZWQgdG8gdGhlIHJlcXVlc3QgaW4gdGhlXG4gICAqICBbXCJBdXRob3JpemF0aW9uXCIgaGVhZGVyXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1vYXV0aC12Mi1iZWFyZXItMjAjc2VjdGlvbi0yLjEpLlxuICAgKlxuICAgKiBJZiBpdCByZXR1cm5zIGZhbHNlLCB0aGUgcmVxdWVzdCBwcm9jZWVkcyB3aXRob3V0IHRoZSBhY2Nlc3MgdG9rZW4gYXR0YWNoZWQuXG4gICAqL1xuICB1cmlNYXRjaGVyPzogKHVyaTogc3RyaW5nKSA9PiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIFNESyB3aGVuIHJldHJpZXZpbmcgdGhlXG4gICAqIGFjY2VzcyB0b2tlbiB0byBhdHRhY2ggdG8gdGhlIG91dGdvaW5nIHJlcXVlc3QuXG4gICAqL1xuICB0b2tlbk9wdGlvbnM/OiBHZXRUb2tlblNpbGVudGx5T3B0aW9ucztcblxuICAvKipcbiAgICogVGhlIEhUVFAgbWV0aG9kIHRvIG1hdGNoIG9uLiBJZiBzcGVjaWZpZWQsIHRoZSBIVFRQIG1ldGhvZCBvZlxuICAgKiB0aGUgb3V0Z29pbmcgcmVxdWVzdCB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCB0aGlzLiBJZiB0aGVyZSBpcyBubyBtYXRjaCwgdGhlXG4gICAqIEF1dGhvcml6YXRpb24gaGVhZGVyIGlzIG5vdCBhdHRhY2hlZC5cbiAgICpcbiAgICogVGhlIEhUVFAgbWV0aG9kIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUuXG4gICAqL1xuICBodHRwTWV0aG9kPzogSHR0cE1ldGhvZCB8IHN0cmluZztcblxuICAvKipcbiAgICogQWxsb3cgdGhlIEhUVFAgY2FsbCB0byBiZSBleGVjdXRlZCBhbm9ueW1vdXNseSwgd2hlbiBubyB0b2tlbiBpcyBhdmFpbGFibGUuXG4gICAqXG4gICAqIFdoZW4gb21pdHRlZCAob3Igc2V0IHRvIGZhbHNlKSwgY2FsbHMgdGhhdCBtYXRjaCB0aGUgY29uZmlndXJhdGlvbiB3aWxsIGZhaWwgd2hlbiBubyB0b2tlbiBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBhbGxvd0Fub255bW91cz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdXRoQ29uZmlnIGV4dGVuZHMgQXV0aDBDbGllbnRPcHRpb25zIHtcbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIGlmIHRoZSBwYWdlIFVSTCBoYXMgY29kZSBhbmQgc3RhdGUgcGFyYW1ldGVycywgdGhlIFNESyB3aWxsIGFzc3VtZSB0aGV5IGFyZSBmb3JcbiAgICogYW4gQXV0aDAgYXBwbGljYXRpb24gYW5kIGF0dGVtcHQgdG8gZXhjaGFuZ2UgdGhlIGNvZGUgZm9yIGEgdG9rZW4uXG4gICAqIEluIHNvbWUgY2FzZXMgdGhlIGNvZGUgbWlnaHQgYmUgZm9yIHNvbWV0aGluZyBlbHNlIChlLmcuIGFub3RoZXIgT0F1dGggU0RLKS4gSW4gdGhlc2VcbiAgICogaW5zdGFuY2VzIHlvdSBjYW4gaW5zdHJ1Y3QgdGhlIGNsaWVudCB0byBpZ25vcmUgdGhlbSBieSBzZXR0aW5nIGBza2lwUmVkaXJlY3RDYWxsYmFja2AuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEF1dGhNb2R1bGUuZm9yUm9vdCh7XG4gICAqICAgc2tpcFJlZGlyZWN0Q2FsbGJhY2s6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9PT0gJy9vdGhlci1jYWxsYmFjaydcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqICoqTm90ZSoqOiBJbiB0aGUgYWJvdmUgZXhhbXBsZSwgYC9vdGhlci1jYWxsYmFja2AgaXMgYW4gZXhpc3Rpbmcgcm91dGUgdGhhdCB3aWxsIGJlIGNhbGxlZFxuICAgKiBieSBhbnkgb3RoZXIgT0F1dGggcHJvdmlkZXIgd2l0aCBhIGBjb2RlYCAob3IgYGVycm9yYCBpbiBjYXNlIHdoZW4gc29tZXRoaW5nIHdlbnQgd3JvbmcpIGFuZCBgc3RhdGVgLlxuICAgKlxuICAgKi9cbiAgc2tpcFJlZGlyZWN0Q2FsbGJhY2s/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgYnVpbHQtaW4gSHR0cCBJbnRlcmNlcHRvciwgdXNlZCBmb3JcbiAgICogYXV0b21hdGljYWxseSBhdHRhY2hpbmcgYWNjZXNzIHRva2Vucy5cbiAgICovXG4gIGh0dHBJbnRlcmNlcHRvcj86IEh0dHBJbnRlcmNlcHRvckNvbmZpZztcblxuICAvKipcbiAgICogUGF0aCBpbiB5b3VyIGFwcGxpY2F0aW9uIHRvIHJlZGlyZWN0IHRvIHdoZW4gdGhlIEF1dGhvcml6YXRpb24gc2VydmVyXG4gICAqIHJldHVybnMgYW4gZXJyb3IuIERlZmF1bHRzIHRvIGAvYFxuICAgKi9cbiAgZXJyb3JQYXRoPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFuZ3VsYXIgc3BlY2lmaWMgc3RhdGUgdG8gYmUgc3RvcmVkIGJlZm9yZSByZWRpcmVjdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFwcFN0YXRlIHtcbiAgLyoqXG4gICAqIFRhcmdldCBwYXRoIHRoZSBhcHAgZ2V0cyByb3V0ZWQgdG8gYWZ0ZXJcbiAgICogaGFuZGxpbmcgdGhlIGNhbGxiYWNrIGZyb20gQXV0aDAgKGRlZmF1bHRzIHRvICcvJylcbiAgICovXG4gIHRhcmdldD86IHN0cmluZztcblxuICAvKipcbiAgICogQW55IGN1c3RvbSBwYXJhbWV0ZXIgdG8gYmUgc3RvcmVkIGluIGFwcFN0YXRlXG4gICAqL1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbi8qKlxuICogSW5qZWN0aW9uIHRva2VuIGZvciBhY2Nlc3NpbmcgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIFVzZSB0aGUgYEluamVjdGAgZGVjb3JhdG9yIHRvIGFjY2VzcyB0aGUgY29uZmlndXJhdGlvbiBmcm9tIGEgc2VydmljZSBvciBjb21wb25lbnQ6XG4gKlxuICogYGBgXG4gKiBjbGFzcyBNeVNlcnZpY2UoQEluamVjdChBdXRoQ29uZmlnU2VydmljZSkgY29uZmlnOiBBdXRoQ29uZmlnKSB7fVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBBdXRoQ29uZmlnU2VydmljZSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxBdXRoQ29uZmlnPihcbiAgJ2F1dGgwLWFuZ3VsYXIuY29uZmlnJ1xuKTtcblxuLyoqXG4gKiBHZXRzIGFuZCBzZXRzIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBpbnRlcm5hbCBBdXRoMCBjbGllbnQuIFRoaXMgY2FuIGJlXG4gKiB1c2VkIHRvIHByb3ZpZGUgY29uZmlndXJhdGlvbiBvdXRzaWRlIG9mIHVzaW5nIEF1dGhNb2R1bGUuZm9yUm9vdCwgaS5lLiBmcm9tXG4gKiBhIGZhY3RvcnkgcHJvdmlkZWQgYnkgQVBQX0lOSVRJQUxJWkVSLlxuICpcbiAqIEB1c2FnZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBhcHAubW9kdWxlLnRzXG4gKiAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGltcG9ydCB7IEF1dGhNb2R1bGUsIEF1dGhDbGllbnRDb25maWcgfSBmcm9tICdAYXV0aDAvYXV0aDAtYW5ndWxhcic7XG4gKlxuICogLy8gUHJvdmlkZSBhbiBpbml0aWFsaXplciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlXG4gKiBmdW5jdGlvbiBjb25maWdJbml0aWFsaXplcihcbiAqICAgaHR0cDogSHR0cENsaWVudCxcbiAqICAgY29uZmlnOiBBdXRoQ2xpZW50Q29uZmlnXG4gKiApIHtcbiAqICAgcmV0dXJuICgpID0+XG4gKiAgICAgaHR0cFxuICogICAgICAgLmdldCgnL2NvbmZpZycpXG4gKiAgICAgICAudG9Qcm9taXNlKClcbiAqICAgICAgIC50aGVuKChsb2FkZWRDb25maWc6IGFueSkgPT4gY29uZmlnLnNldChsb2FkZWRDb25maWcpKTsgICAvLyBTZXQgdGhlIGNvbmZpZyB0aGF0IHdhcyBsb2FkZWQgYXN5bmNocm9ub3VzbHkgaGVyZVxuICogfVxuICpcbiAqIC8vIFByb3ZpZGUgQVBQX0lOSVRJQUxJWkVSIHdpdGggdGhpcyBmdW5jdGlvbi4gTm90ZSB0aGF0IHRoZXJlIGlzIG5vIGNvbmZpZyBwYXNzZWQgdG8gQXV0aE1vZHVsZS5mb3JSb290XG4gKiBpbXBvcnRzOiBbXG4gKiAgIC8vIG90aGVyIGltcG9ydHMuLlxuICpcbiAqICAgSHR0cENsaWVudE1vZHVsZSxcbiAqICAgQXV0aE1vZHVsZS5mb3JSb290KCksICAgLy88LSBkb24ndCBwYXNzIGFueSBjb25maWcgaGVyZVxuICogXSxcbiAqIHByb3ZpZGVyczogW1xuICogICB7XG4gKiAgICAgcHJvdmlkZTogQVBQX0lOSVRJQUxJWkVSLFxuICogICAgIHVzZUZhY3Rvcnk6IGNvbmZpZ0luaXRpYWxpemVyLCAgICAvLyA8LSBwYXNzIHlvdXIgaW5pdGlhbGl6ZXIgZnVuY3Rpb24gaGVyZVxuICogICAgIGRlcHM6IFtIdHRwQ2xpZW50LCBBdXRoQ2xpZW50Q29uZmlnXSxcbiAqICAgICBtdWx0aTogdHJ1ZSxcbiAqICAgfSxcbiAqIF0sXG4gKiBgYGBcbiAqXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgQXV0aENsaWVudENvbmZpZyB7XG4gIHByaXZhdGUgY29uZmlnPzogQXV0aENvbmZpZztcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KEF1dGhDb25maWdTZXJ2aWNlKSBjb25maWc/OiBBdXRoQ29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBjb25maWd1cmF0aW9uIHRvIGJlIHJlYWQgYnkgb3RoZXIgY29uc3VtZXJzIG9mIHRoZSBzZXJ2aWNlIChzZWUgdXNhZ2Ugbm90ZXMpXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gc2V0XG4gICAqL1xuICBzZXQoY29uZmlnOiBBdXRoQ29uZmlnKTogdm9pZCB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29uZmlnIHRoYXQgaGFzIGJlZW4gc2V0IGJ5IG90aGVyIGNvbnN1bWVycyBvZiB0aGUgc2VydmljZVxuICAgKi9cbiAgZ2V0KCk6IEF1dGhDb25maWcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZyBhcyBBdXRoQ29uZmlnO1xuICB9XG59XG4iXX0=